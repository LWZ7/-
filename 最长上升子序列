def Lis(a):
    num = [1 for i in range(len(a))]
    for i in range(len(a)):
        for j in range(i):
            if a[j]<a[i] and num[j]+1 > num[i]:
                num[i]+=1
    return max(num)
    
    
我一开始的想法是，前一个数字跟当前数字比较大小，但发现这样不行。
这道题的解法是：创建一个数组，长度为序列大小，初始值为1.
两层循环，第一次遍历到一个数字时，要与前面的所有数字比较，如果第二层循环的数字比第一层的小，并且a[j]+1>a[i]，a[i]+=1
为什么要第二步呢？
第二层循环其实相当于是在找当前位置的最长序列，从头遍历，如果某一个位置既符合a[j]<a[i]且a[j]+1>a[i]，说明最长序列要增加了

